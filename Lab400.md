
## Lab 400 - Wercker를 통한 배포 자동화
소스 변경으로 인해 Git에 Commit이 발생하면 빌드이후 배포되는 과정으로 Registry에 등록된 Image를 Kuberneted(OKE)에 배포하는 것 까지 실습합니다.


### **STEP 1**: Git 소스에 Kubernetes 배포 파일 - `kubernetes.yml`
kubectl로 배포하기 위해서는 배포용 yml 파일이 필요합니다.

1. GitHub으로 접속하여, **twitter-feed** 레포지토리에서 `kubernetes.yml`을 클릭합니다.

2. 아래와 같은 파일 내용을 볼 수 있습니다.
    ```yaml
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
    name: twitter-feed-v1
    labels:
        commit: ${WERCKER_GIT_COMMIT}
    spec:
    replicas: 2
    selector:
        matchLabels:
        app: twitter-feed
    template:
        metadata:
        labels:
            app: twitter-feed
            commit: ${WERCKER_GIT_COMMIT}
        spec:
        containers:
        - name: twitter-feed
            image: ${DOCKER_REGISTRY_HOST_PORT}/${DOCKER_REPOSITORY_NAME}:${WERCKER_GIT_BRANCH}-${WERCKER_GIT_COMMIT}
            imagePullPolicy: Always
            ports:
            - name: twitter-feed
            containerPort: 8080
            protocol: TCP
        imagePullSecrets:
            - name: wercker
    ---
    apiVersion: v1
    kind: Service
    metadata:
    name: twitter-feed
    labels:
        app: twitter-feed
        commit: ${WERCKER_GIT_COMMIT}
    spec:
    ports:
    - port: 30000
        targetPort: 8080
    selector:
        app: twitter-feed
    type: ClusterIP
    ---
    ```

3. kubernetes.yml 설명
    * kind: Deployment
        - 배포 관련한 내용을 정의합니다.
        - replicas: 2로 2개의 Pod을 만듭니다.
        - image: ${DOCKER_REGISTRY_HOST_PORT}/${DOCKER_REPOSITORY_NAME}:${WERCKER_GIT_BRANCH}-${WERCKER_GIT_COMMIT} 로 이후 kubectl을 통해 Wercker를 통해 이전단계에서 Registry에 Push한 그 이름의 이미지를 가져와서 사용합니다.
    * kind: Service
        - 서비스는 배포한 애플리케이션을 서비스하는 부분을 정의합니다. 현재는 ClusterIP 타입으로 내부에서만 서비스합니다.

### **STEP 2**: Git 소스에 Kubernetes 배포 파일 - `alpha-office-product-catalog.kubernetes.yml`
kubectl로 배포하기 위해서는 배포용 yml 파일이 필요합니다. UI용 배포 파일입니다.

1. GitHub으로 접속하여, **twitter-feed** 레포지토리에서 `alpha-office-product-catalog.kubernetes.yml`을 클릭합니다.

2. 아래와 같은 파일 내용을 볼 수 있습니다.
    ```yaml
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
    name: product-catalog-app
    labels:
        commit: 4ca160fd05c003e5067fd6d9c8213656b24b962c
    spec:
    replicas: 2
    selector:
        matchLabels:
        app: product-catalog-app
    template:
        metadata:
        labels:
            app: product-catalog-app
            commit: 4ca160fd05c003e5067fd6d9c8213656b24b962c
        spec:
        containers:
        - name: product-catalog-app-container
            image: derekoneil/alpha-office-product-catalog:master-4ca160fd05c003e5067fd6d9c8213656b24b962c
            imagePullPolicy: Always
            ports:
            - name: pc-app-port
            containerPort: 80
            protocol: TCP
        imagePullSecrets:
            - name: wercker
    ---
    apiVersion: v1
    kind: Service
    metadata:
    name: product-catalog-service
    labels:
        app: product-catalog-app
        commit: 4ca160fd05c003e5067fd6d9c8213656b24b962c
    spec:
    ports:
    - port: 30000
        targetPort: 80
    selector:
        app: product-catalog-app
        commit: 4ca160fd05c003e5067fd6d9c8213656b24b962c
    type: LoadBalancer
    ---
    ```

3. alpha-office-product-catalog.kubernetes.yml 설명
    * kind: Deployment
        - 배포 관련한 내용을 정의합니다.
        - replicas: 2로 2개의 Pod을 만듭니다.
        - image: derekoneil/alpha-office-product-catalog:master-4ca160fd05c003e5067fd6d9c8213656b24b962c로 별도로 이미 만들어 놓은 이미지를 가져와서 사용합니다.
    * kind: Service
        - 서비스는 배포한 애플리케이션을 서비스하는 부분을 정의합니다. 현재는 LoadBalancer 타입으로 외부에서 접속할 수 있습니다.


### **STEP 3**: wercker.yml 파일에 쿠버네티스 배포용 파이프라인 정의

1. **wercker.yml** 파일을 클릭하고 **연필** 버튼을 클릭
    ![](images/200/26.png)

2. 아래의 YAML 을 **복사** 해서 제일 밑에 **붙여넣기** 한다. 

    ```yaml
    #Deploy our container from the Oracle Container Registry to the Oracle Container Engine (Kubernetes)
    deploy-to-cluster:
      box:
          id: alpine
          cmd: /bin/sh

      steps:

      - bash-template

      - kubectl:
          name: delete secret
          server: $KUBERNETES_MASTER
          token: $KUBERNETES_AUTH_TOKEN
          insecure-skip-tls-verify: true
          command: delete secret wercker; echo delete registry secret

      - kubectl:
          name: create secret
          server: $KUBERNETES_MASTER
          token: $KUBERNETES_AUTH_TOKEN
          insecure-skip-tls-verify: true
          command: create secret docker-registry wercker --docker-server=$DOCKER_REGISTRY --docker-email=nobody@oracle.com --docker-username=$DOCKER_USERNAME --docker-password='$OCI_AUTH_TOKEN'; echo create registry secret

      - script:
          name: "Visualise Kubernetes config"
          code: cat kubernetes.yml

      - kubectl:
          name: deploy twitter-feed to kubernetes
          server: $KUBERNETES_MASTER
          token: $KUBERNETES_AUTH_TOKEN
          insecure-skip-tls-verify: true
          command: apply -f kubernetes.yml
          
      - kubectl:
          name: deploy alpha-office-catalog to kubernetes
          server: $KUBERNETES_MASTER
          token: $KUBERNETES_AUTH_TOKEN
          insecure-skip-tls-verify: true
          command: apply -f alpha-office-product-catalog.kubernetes.yml
    ```

3. **deploy-to-cluster** 파이프라인을 정의하는 것으로, Wercker에서 **kubectl**를 이용해 OKE Cluster에 애플리케이션을 배포합니다.

4. **deploy-to-cluster** 파이프라인에서는 앞서 설명한 두 개의 .yml 파일을 이용해 두 개의 애플리케이션을 배포합니다. 하나는 위에서 빌드한 **twitter-feed** 애플리케이션이과 나머지 하나는 UI가 있는 WebApp 인 **alpha-office-product-catalog** 입니다.

5. 페이지 제일 밑에 Commit changes 클릭하여 저장
  ![](images/200_commit_changes.png)
